package main;

import java.awt.AWTException;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.PointerInfo;
import java.awt.Robot;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.util.Random;

import javax.swing.JFrame;
import javax.swing.JOptionPane;

/*
 * We will use this class to train magic by enchanting.
 * 
 * 1. The magic way that is trained is defined by the glyph
 * in your left hand. 
 * 
 * 2. The gems you are using are defined by the gems in the 
 * two top rows of your inventory. Make sure every gem stack 
 * has 65 gems.
 * 
 * 3. IMPORTANT: You have to set the pickup behavior so that
 * only one item is picked up every time you left click.
 * 
 * In this class we will move the mouse courser.
 * Because of this it is important that the windows are aligned neatly.
 * 
 * 4. In the bottom right corner of the PS screen should be the buddy list.
 * Next to it should be the inventory and last the Container of the enchanter.
 * The windows shall be aligned side by side, without space in between and
 * without space to the bottom of the window.
 * 
 * 5. If you start the program, you have a few seconds time to put the course
 * above the gem in the first column of the top row of your inventory.
 */


public class TrainMagic {
	
	public static void main(String[] args) throws AWTException, InterruptedException, IOException {
		
		// Time to change to Planeshift window
		Thread.sleep(5000);
		
		/*-----------*/
						
		/* PARAMETER */
		int castingTime = 120000; //in ms
		int mentalStaminaRecharchTime = 35000; //in ms
		// Count after how many castings we need to recharch our stamina
		int numberOfCastsUntilRecharch = 4;
		int numOfGemsInEachStack = 65;
		int numOfStacksWeWantToCast = 4;
		boolean withChatting = false;
		
		
		/*-----------*/
				
		//Runtime.getRuntime().exec("SwitchToPlaneshift.vbs");
		
		/*
		 * Positions:
		 * 
		 * Inventory, stack, top-left: 1567, 609
		 * Inventory, space height/width: 40
		 * Container, use-key: 1484, 712
		 * Container, empty space top left: 1473, 790
		 * Container, take-all button: 1354, 747
		 */
		
		int posX_currStack = 1567;
		int posY_currStack = 609;
		int posX_useKey = 1484;
		int posY_useKey = 712;
		int posX_dropOff = 1473;
		int posY_dropOff = 790;
		int posX_takeAll = 1354;
		int posY_takeAll = 747;
		int posX_moveStack = 40;
		int posY_moveStack = 40;
		
		/*
		 * Use this to figure out, which coordinates to use
		 */
		// Get the x and y coordinate, where we place the mouse at first
//		PointerInfo a = MouseInfo.getPointerInfo();
//	    Point b = a.getLocation();
//	    int startPointX = (int) b.getX();
//	    int startPointY = (int) b.getY();
//	    
//	    System.out.printf("%d, %d", startPointX, startPointY);
//	    System.exit(0);
		
		Pair<String, String> lastChatLines = new Pair("", "");
		
//		// For Testing
//		for(int z = 0; z < 60; z++) {
//			lastChatLines = Utilities.chatWithIRC(lastChatLines);
//		
//			Thread.sleep(2000);
//		}
//		System.exit(0);
		
		// Robot which presses the keys
		Robot robot = new Robot();
		
		// Left Mouse Key
		int keyLeftMouse = InputEvent.BUTTON1_MASK;
		
		// Create some randomness
		Random dice = new Random();
		
		// Count the remaining stacks in the current row
		int stacksInRow = 4;
		// Count the gems until next recharch
		int countMentalStaminaRecharch = numberOfCastsUntilRecharch;
		// Count the gems in the current stack
		int stackCount = numOfGemsInEachStack;
		
		// Clear the container before we start
		robot.mouseMove(posX_takeAll, posY_takeAll);
		robot.mousePress(keyLeftMouse);
		Thread.sleep(dice.nextInt(100));
		robot.mouseRelease(keyLeftMouse);
		
		for(int i = 0; i < numOfStacksWeWantToCast*numOfGemsInEachStack; i++) {
			
			// Is a Game Master on?
			boolean gameMasterOn = Utilities.checkForGM();
			if(gameMasterOn) {
				JOptionPane.showMessageDialog(new JFrame(), "Training is ommited due to GM!", "Shut Down", JOptionPane.ERROR_MESSAGE);
				break;
			}
			
			// Chat
			if(withChatting) {
				lastChatLines = Utilities.chatWithIRC(lastChatLines);
			}
			
			//Summon mount
			Utilities.summonMount();
			
			robot.mouseMove(posX_currStack, posY_currStack);
			
			robot.mousePress(keyLeftMouse);
			Thread.sleep(dice.nextInt(100));
			robot.mouseRelease(keyLeftMouse);
			
			robot.mouseMove(posX_dropOff, posY_dropOff);
			
			robot.mousePress(keyLeftMouse);
			Thread.sleep(dice.nextInt(100));
			robot.mouseRelease(keyLeftMouse);
			
			robot.mouseMove(posX_useKey, posY_useKey);
			
			robot.mousePress(keyLeftMouse);
			Thread.sleep(dice.nextInt(100));
			robot.mouseRelease(keyLeftMouse);
			
			// We have used one gem, so the stack is one less.
			stackCount -= 1;
			
			System.out.println("Remain crystals in stack: " + stackCount);
			
			// The natural value can be higher 
			// than the time for the next key press.
			// This way its more natural.
			Thread.sleep(castingTime + 1 + dice.nextInt(5000));
			
			robot.mouseMove(posX_takeAll, posY_takeAll);
			
			robot.mousePress(keyLeftMouse);
			Thread.sleep(dice.nextInt(100));
			robot.mouseRelease(keyLeftMouse);
			
			// Mental Stamina Recharch
			countMentalStaminaRecharch -= 1;
			if(countMentalStaminaRecharch == 0) {
				// 30s, could be higher/lower
				Thread.sleep(mentalStaminaRecharchTime + dice.nextInt(3000));
				countMentalStaminaRecharch = numberOfCastsUntilRecharch;
			}
			
			// We have used one complete stack
			if(stackCount == 0) {
				stackCount = numOfGemsInEachStack;
				
				// We have finished stack in the row
				stacksInRow -= 1;
				System.out.print("Stacks in row: " + stacksInRow);
				// We have finished a complete row of 4 stacks
				if(stacksInRow == 0) {
					posX_currStack -= (posX_moveStack * 3);
					posY_currStack += posY_moveStack;
					stacksInRow = 4;
				} else { // We still have stacks in the row
					posX_currStack += posX_moveStack;
				}
			}
			
		}

		

	}

}
